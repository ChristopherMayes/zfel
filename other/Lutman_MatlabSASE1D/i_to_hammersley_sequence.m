function r = i_to_hammersley_sequence ( dim_num, n, step, seed, leap, base )

%%% I_TO_HAMMERSLEY_SEQUENCE: next N elements of an DIM_NUM-dimensional Hammersley sequence.
%
%  Discussion:
%
%    The DIM_NUM-dimensional Hammersley sequence is really DIM_NUM separate
%    sequences, each generated by a particular base.  If the base is 
%    greater than 1, a standard 1-dimensional
%    van der Corput sequence is generated.  But if the base is 
%    negative, this is a signal that the much simpler sequence J/(-BASE) 
%    is to be generated.  For the standard Hammersley sequence, the
%    first spatial coordinate uses a base of (-N), and subsequent
%    coordinates use bases of successive primes (2, 3, 5, 7, 11, ...).
%    This program allows the user to specify any combination of bases,
%    included nonprimes and repeated values.
%
%    This routine selects elements of a "leaped" subsequence of the
%    Hammersley sequence.  The subsequence elements are indexed by a
%    quantity called STEP, which starts at 0.  The STEP-th subsequence
%    element is simply element
%
%      SEED(1:DIM_NUM) + STEP * LEAP(1:DIM_NUM)
%
%    of the original Hammersley sequence.
%
%  Modified:
%
%    30 September 2004
%
%  Author:
%
%    John Burkardt
%
%  Reference:
%
%    J M Hammersley,
%    Monte Carlo methods for solving multivariable problems,
%    Proceedings of the New York Academy of Science,
%    Volume 86, 1960, pages 844-874.
%
%    Ladislav Kocis and William Whiten,
%    Computational Investigations of Low-Discrepancy Sequences,
%    ACM Transactions on Mathematical Software,
%    Volume 23, Number 2, 1997, pages 266-294.
%
%  Parameters:
%
%    Input, integer DIM_NUM, the spatial dimension.
%    1 <= DIM_NUM is required.
%
%    Input, integer N, the number of elements of the sequence.
%
%    Input, integer STEP, the index of the subsequence element.
%    0 <= STEP is required.
%
%    Input, integer SEED(DIM_NUM), the sequence index corresponding
%    to STEP = 0.
%
%    Input, integer LEAP(DIM_NUM), the succesive jumps in the sequence.
%
%    Input, integer BASE(DIM_NUM), the bases.
%
%    Output, double precision R(DIM_NUM,N), the next N elements of the
%    leaped subsequence, beginning with element STEP.
%
  fiddle = 1.0;
  dim_num = floor ( dim_num );
  n = floor ( n );
  step = floor ( step );
  seed(1:dim_num) = floor ( seed(1:dim_num) );
  leap(1:dim_num) = floor ( leap(1:dim_num) );
  base(1:dim_num) = floor ( base(1:dim_num) );
%
%  Check the input.
%
  if ( ~halham_dim_num_check ( dim_num ) )
    error ( 'I_TO_HAMMERSLEY_SEQUENCE - Fatal error!' );
  end

  if ( ~halham_n_check ( n ) )
    error ( 'I_TO_HAMMERSLEY_SEQUENCE - Fatal error!' );
  end

  if ( ~halham_step_check ( step ) )
    error ( 'I_TO_HAMMERSLEY_SEQUENCE - Fatal error!' );
  end

  if ( ~halham_seed_check ( dim_num, seed ) )
    error ( 'I_TO_HAMMERSLEY_SEQUENCE - Fatal error!' );
  end

  if ( ~halham_leap_check ( dim_num, leap ) )
    error ( 'I_TO_HAMMERSLEY_SEQUENCE - Fatal error!' );
  end

  if ( ~hammersley_base_check ( dim_num, base ) )
    error ( 'I_TO_HAMMERSLEY_SEQUENCE - Fatal error!' );
  end
%
%  Calculate the data.
%
  r(1:dim_num,1:n) = 0.0;
  
  for i = 1: dim_num

    if ( 1 < base(i) )

      seed2(1:n) = seed(i) + step * leap(i) : leap(i) : ...
                   seed(i) + ( step + n - 1 ) * leap(i);

      base_inv = 1.0 / base(i);
  
      % Bit reversal routine.  (Write seed sequence in bit representation
      % in base of "base(i)."  Then reverse bits: 110 --> .011, so if
      % base(i) = 2, 6 --> .375.
      while ( any ( seed2 ~= 0 ) )
        digit(1:n) = mod ( seed2(1:n), base(i) );
        r(i,1:n) = r(i,1:n) + digit(1:n) * base_inv;
        base_inv = base_inv / base(i);
        seed2(1:n) = floor ( seed2(1:n) / base(i) );
      end
%
%  In the following computation, the value of FIDDLE can be:
%
%    0,   for the sequence 0/N, 1/N, ..., N-1/N
%    1,   for the sequence 1/N, 2/N, ..., N/N
%    1/2, for the sequence 1/(2N), 3/(2N), ..., (2*N-1)/(2N)
%
    else

      temp(1:n) = seed(i) + step * leap(i) : leap(i) : ...
                 seed(i) + ( step + n - 1 ) * leap(i);

      r(i,1:n) = ( mod ( temp(1:n), -base(i) ) + fiddle ) / ( -base(i) );

    end

  end


%
% ----------------------------------------------------------
function value = halham_dim_num_check ( dim_num )

%% HALHAM_DIM_NUM_CHECK checks DIM_NUM for a Halton or Hammesley sequence.
%
%  Modified:
%
%    04 August 2005
%
%  Author:
%
%    John Burkardt
%
%  Parameters:
%
%    Input, integer DIM_NUM, the new value for the dimension.
%
%    Output, logical VALUE, is true if DIM_NUM is legal.
%
  if ( dim_num < 1 )
    fprintf ( 1, '\n' );
    fprintf ( 1, 'HALHAM_DIM_NUM_SET - Fatal error!\n' );
    fprintf ( 1, '  Input value of DIM_NUM < 1!\n' );
    fprintf ( 1, '  DIM_NUM = %d\n', dim_num );
    value = 0;
  else
    value = 1;
  end
  

  
%
% ----------------------------------------------------------
function value = halham_leap_check ( dim_num, leap )

%% HALHAM_LEAP_CHECK checks LEAP for a Halton or Hammersley sequence.
%
%  Modified:
%
%    21 September 2004
%
%  Author:
%
%    John Burkardt
%
%  Parameters:
%
%    Input, integer LEAP(1:DIM_NUM), the leap vector.  
%    Each entry should be 1 or greater.  Only the integer
%    part of a base is used.
%
%    Output, logical VALUE, is true if LEAP is legal.
%
  if ( any ( leap(1:dim_num) < 1 ) )
    fprintf ( 1, '\n' );
    fprintf ( 1, 'HALHAM_LEAP_CHECK - Fatal error!\n' );
    fprintf ( 1, '  At least one of the input leap entries is <= 1!\n' );
    value = 0;
  else
    value = 1;
  end



%
% ----------------------------------------------------------
function value = halham_n_check ( n )

%% HALHAM_N_CHECK checks N for a Halton or Hammersley sequence.
%
%  Modified:
%
%    21 September 2004
%
%  Author:
%
%    John Burkardt
%
%  Parameters:
%
%    Input, integer N, the number of points in the subsequence.
%
%    Output, logical VALUE, is true if N is legal.
%
  if ( n < 1 )
    fprintf ( 1, '\n' );
    fprintf ( 1, 'HALHAM_N_CHECK - Fatal error!\n' );
    fprintf ( 1, '  Input value of N < 1!\n' );
    fprintf ( 1, '  N = %d\n', n );
    value = 0;
  else
    value = 1;
  end




%
% ----------------------------------------------------------
function value = halham_seed_check ( dim_num, seed )

%% HALHAM_SEED_SET checks SEED for a Halton or Hammersley sequence.
%
%  Modified:
%
%    21 September 2004
%
%  Author:
%
%    John Burkardt
%
%  Parameters:
%
%    Input, integer DIM_NUM, the spatial dimension.
%
%    Input, integer SEED(1:DIM_NUM), the seed of the leaped subsequence.  
%    Each base should be greater than 1.
%
%    Output, logical VALUE, is true if SEED is legal.
%
  if ( any ( seed(1:dim_num) < 0 ) )
    fprintf ( 1, '\n' );
    fprintf ( 1, 'HALHAM_SEED_CHECK - Fatal error!\n' );
    fprintf ( 1, '  At least one of the input seeds is < 0!\n' );
    value = 0;
  else
    value = 1;
  end




%
% ----------------------------------------------------------
function value = halham_step_check ( step )

%% HALHAM_STEP_CHECK checks STEP for a Halton or Hammersley sequence.
%
%  Modified:
%
%    21 September 2004
%
%  Author:
%
%    John Burkardt
%
%  Parameters:
%
%    Input, integer STEP, the step of the leaped subsequence.
%
%    Output, logical VALUE, is true if STEP is legal.
%
  if ( step < 0 )
    fprintf ( 1, '\n' );
    fprintf ( 1, 'HALHAM_STEP_CHECK - Fatal error!\n' );
    fprintf ( 1, '  Input value of STEP < 0!\n' );
    fprintf ( 1, '  STEP = %d\n', step );
    value = 0;
  else
    value = 1;
  end




%
% ----------------------------------------------------------
function value = hammersley_base_check ( dim_num, base )

%% HAMMERSLEY_BASE_CHECK checks BASE for a Hammersley sequence.
%
%  Modified:
%
%    21 September 2004
%
%  Author:
%
%    John Burkardt
%
%  Parameters:
%
%    Input, integer BASE(1:DIM_NUM), the bases.  
%    Bases should not be 0 or 1.
%
%    Output, logical VALUE, is true if BASE is legal.
%
  if ( any ( base(1:dim_num) == 0 ) | any ( base(1:dim_num) == 1 ) )
    fprintf ( 1, '\n' );
    fprintf ( 1, 'HAMMERSLEY_BASE_CHECK - Fatal error!\n' );
    fprintf ( 1, '  BASE(I) = 0 or 1 for some I!\n' );
    value = 0;
  else
    value = 1;
  end

